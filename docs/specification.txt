Language Summary
----------------
Ishlang is a fully parenthesized prefix notation programming language inspired by Lisp. Though
it is influnced by Lisp, the language diverts considerably from Lisp.

The name Ishlang (ish-lang) is shorthand for "Lisp'ish programming language", and
was chosen to pay homage to the Lisp programming language. It was a conscious decision to not
name the language lispish (even though that was a first choice) as the language is not a lisp
implementation, and does not try to be a lisp'ish implementation. Though many decisions
and language features might look like lisp, there is no "lisp metric" that is being
used in the development of Ishlang.

Example: Hello world Program
  (println "Hello World")

Values
------
Every expression in ishlang evaluates to a value. A value can hold any of the following types:
  none, int, real, char, bool, string, array, closure, usertype, userobject

Literals
--------
Can be none, char, int, real, bool, and string. Examples:
- none:   null
- char:   'a'
- string: "hello"
- int:    30
- real:   25.25
- bool:   true

Reserved literal keywords: null, true, false

Variables
---------
Defining: (var <name> <expression>)
- Example: (var number 5)

Assignment: (= <name> <expression>)
- Example: (= number 10)

Exists check: (? <name>)
- Example: (? number)

Input / Output
--------------
- Printing: (print <expression>) or (println <expression>)
  Examples:
    (print "Hello ")
    (println "World")

  The functions print and println evaluate to null value

- Reading: (read)
  Example:
    (var something (read))

Arithmetic
----------
Supported operations: + - * / %
  (<op> <expression> <expression>)

Examples:
  (+ 10 12)
  (* 2 5)

Logical
-------
Binary operations: == != < > <= >= and or
  (op <expression> <expression>)

Unary operation:
  (not <expression>)

Examples:
  (== x y)
  (or (== x y) (> y 10))
  (not true)

If Statement
------------
(if <condition_expression> <true_expression> [<false_expression>])

Example:
  (if (> x 0) 1 0)

When Statement
--------------
(when <condition_expression> <true_expression>)

The when form is syntactic sugar for the following if/true statement:
  (if <condition_expression> <true_expression>)

Example:
  (when (> x 0) 1)

Unless Statement
----------------
(unless <condition_expression> <false_expression>)

The unless form is syntactic sugar for the following if/not statement:
  (if (not <condition_expression>) <true_expression>)

Example:
  (unless (<= x 0) 1)

Cond Statement
--------------
(cond
  (<condition> <expression>)
  ...
  (true <expression>))

The (true <expression>) case acts as a default catch all case, and is optional

Example:
  (var check1 false)
  (var check2 false)
  ...
  (cond
   (check1 (println "Check1"))
   (check2 (println "Check2"))
   (true   (println "Neither Check")))

Progn and Block
---------------
Progn and block define a sequence of expression, and groups them into one expression.

(progn
  <expression>
  ...)

(block
  <expression>
  ...)

Difference between progn and block is that block defines an new environment and progn does not.

The value of executing a sequence is the result of evaluating the last expression.

Example:
  (progn
    (var x 10)
    (= x (+ x 5))
    (println x))

  (block
    (var x 10)
    (= x (+ x 5))
    (pringln x))

  In the progn case the variable x is defined in the enclosing environment, and as such
  exists outside the boundary of progn. In the block case, the variable x is defined in
  the block environment, and is not available outside the scope of block.

Looping
-------
General form:
  (loop <decl_expression> <cond_expression> <next_expression>
    <body_expression>)

Conditional only form:
  (loop <cond_expression>
    <body_expression>)

Example - general form:

  (var count 0)
  (loop (var i 1) (<= i 10) (= i (+ i 1))
    (= count (+ count i)))

Example - conditional form:

  (var count 0)
  (var term 0)
  (loop (< count 55)
    (progn
      (= term (+ term 1))
      (= count (+ count term))))

Functions
---------
User defined functions:
  (defun <name> <param_list>
    <body>)

Functions can be nested, i.e defined inside other functions.

Language supports recursion.

Example:
  (defun hello ()
    (println "Hello world"))

  (defun add (x y)
    (+ x y))

  (defun foobar (x y)
    (var z (+ x y))
    (if (> z 10)
        (/ z 2)
      z)))

Lambda
------
The lambda expression defines a closure.
  (lambda <param_list>
    <body>)

  The closure environment is the enclosing environment where the lambda is defined.

  When a lambda function is executed, the lambda execution environment will inherit the closure environment.

Examples:
  (lambda (x y)
    (+ x y))

  (var myAdd (lambda (x y) (+ x y)))
  (println (myAdd 2 3))

  (var x 0)
  (var addOne (lambda () (= x (+ x 1))))
  (addOne)
  (println x)

Structs
-------
Define a user type:
  (struct <name>
    <member_list>)

Creating an instance:
  (makeinstance <name>)

Setting / Getting member fields:
  (memget <instance_expression> <member_name>)
  (memset <instance_expression> <member_name> <expression>)

Example:
  (struct Person
    (name
     age))

  (var p (makeinstance Person))
  (memset p name "John")
  (memset p age 25)
  (println (memget p name))
  (println (memget p age))

Type Checking
-------------
Is type of?
  (istypeof <expression> <type>

<type> is one of: none, int, real, char, bool, string, array, closure, usertype, userobject

Example:
  (istypeof 10 int)
  (istypeof Person usertype)

Is struct name?
  (isstructname <expression> <struct>)

Example:
  (var s Person)
  (isstructname s Person)

Is instance of?
  (isinstanceof <expression> <struct>)

Example:
  (var p (makeinstance Person))
  (isinstanceof p Person)

Type Name
---------
Get type name of:
  (typename <expression>)

Returns the name of the type of the expression.

Example:
  (typename 10)
  (typename Person)

Get struct name:
  (structname <expression>)

Returns struct name, expression must be an instance or a struct.

Example:
  (struct Person (name))
  (var p (makeinstance Person))
  (structname p)

Type Conversion
---------------
Convert value to value of another type:
  (astype <expr> <type>)

Supports the following type conversions:
  From    To      Equivalent to
  ----    --      -------------
  int     real    float(from)
  int     char    ascii(from)
  int     bool    from != 0
  int     string  string(from)
  real    int     int(from)
  real    char    ascii(int(from))
  real    bool    int(from) != 0
  real    string  string(from)
  char    int     ascii_value(from)
  char    real    ascii_value(int(from))
  char    bool    from == 't' -> true, from == 'f' -> false
  char    string  string(from)
  bool    int     from == true -> 1, from == false -> 0
  bool    real    from == true -> 1.0, from == false -> 0.0
  bool    char    from == true -> 't', from == false -> 'f'
  bool    string  from == true -> "true", from == false -> "false"
  string  int     int(from)
  string  real    real(from)
  string  char    from[0] or '\0' if empty
  string  bool    from == "true" -> true, from == "false" -> false

Example:
  (astype true int)
  (astype 25.12 int)
  (astype 25 real)
  (astype "10" int)
  (astype 't' bool)
  (astype 99 char)
  (astype 12.34 string)

Cloning
-------
Clone a value:
  (clone <expression>)

  will clone the value resulting from executing expression

Example:
  (var p (makeinstance Person))
  (memset p name "John")
  (memset p age 25)
  (var q (clone p))

String Operations
-----------------
strlen: compute string length
        (strlen <string>)

strget: return character at position
       (strget <string> <position>)

strset: set character at position
       (strset <string> <position> <character>)

strcat: Concatenate string or character to string
        (strcat <string> <other>)

substr: Return substring from given string
        (substr <string> <position> [<length>]

strfind: Find position of character in string
         (strfind <string> <character> [<position>])

Examples:
  (var str "Hello!")
  (println (strlen str))
  (println (strget str 3))
  (strset str 5 ' ')
  (strcat str "World!")
  (println (substr str 0 5))
  (println (strfind str 'W'))

Array Operations
----------------
array: make an array
       (array [<element> [<element ...]])

arraysv: make an array from size and inital value
         default initial value is null
         (arraysv <size> [<inital_value>])

arrlen: return array length
        (arrlen <array>)

arrget: return value at position
        (arrget <array> <position>)

arrset: set value at position
        (arrset <array> <position> <value>)

arradd: Add element to end of array
        (arradd <array> <value>)

arrfind: Find position of value in array
         (arrfind <array> <value> [<position>])

Examples:
  (var a (array))
  (arradd a 1)
  (arradd a 2)
  (println (arrlen a))
  (println (arrget a 0))
  (arrset a 1 20)
  (println (arrget a 0))
  (println (arrget a 1))
  (println (arraysv 5))
  (println (arraysv 10 0))
  (println (arrfind a 2))

Comments
--------
Comments start with ;; and continue for the remainder of the line.
Comments can be occupy full or partial lines.

  ;; <comment text>

Examples:
  ;; This is a function
  (defun x2 (x) ;; Double x
    (* 2 x))
